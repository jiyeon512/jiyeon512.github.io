---
layout: post
title:  "selection sort!"
---


#선택 정렬

1. 선택 정렬 알고리즘 동작 방법

- 가정: 정렬되지 않은 숫자들이 들어 있는 리스트와 정렬이 완료된 숫자들이 들어있는 리스트가 있다. 그림과 같이 초기 상태에서 정렬된 리스트는 비어 있고 정렬되어야 할 숫자들은 모두 오른쪽 리스트에 들어 있다. 선택 정렬은 오른쪽 리스트에서 가장 작은 숫자를 선택하여 오른쪽 리스트에서 가장 작은 숫자를 선택하여 왼쪽 리스트로 이동하는 작업을 반복한다.  이것은 오른쪽 리스트가 공백 상태가 될 때까지 되풀이 된다.

![image](https://user-images.githubusercontent.com/101514626/166663876-4892a3ec-9ec8-44de-a3ef-0be8dcffe410.png)

처음에는 두 개의 리스트로 나누어 설명했지만 실제로 선택 정렬을 구현하기 위해 두 개의 배열을 사용할 필요는 없다. 아래 그림과 같이 정렬이 안 된 리스트에서 최솟값이 선택되면 이 값을 배열의 첫번째 요소와 교환한다. 이렇게 입력 배열 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법을 제자리 정렬(in-place sorting)이라고 한다. 최솟값 1과 첫 번째 요소 5를 교환하면 전체 배열은 정렬된 부분과 되지 않은 부분으로 나뉜다. 다음에는 두 번째 요소부터 나머지 요소들 중에서 가장 작은 값을 선택하고 이를 두 번째 요소와 교환한다. 이 절차를 (숫자 개수 -1)만큼 되풀이하면 추가적인 배열을 사용하지 않고서도 전체 숫자들이 정렬된다.

![image](https://user-images.githubusercontent.com/101514626/166664495-9f492420-199f-49b4-954f-dd6b406ff819.png)



2. 선택 정렬 알고리즘 구현

#include <iostream>
  

using namespace std;

  
inline void swap(int& x, int& y)

  {

  int t = x;
	
  x = y;
	
  y = t;

  }

  
void selectionSort(int a[], int n[])

  {
	
  for (int i = 0; i < n - 1; i++)
	
                       {
		int least = i;

                       for (int j = i + 1; j < n; j++)
		
  {
	
  if (a[j] < a[least])
	
                      least = j;
		
                      }
		
                      swap(a[i], a[least]);
	
                      }

                      }

                      

                      int main()

                      {
	
                      int arr[] = { 2, 7, 5, 1, 3, 9  };

                      
	
                      for (int i = 0; i < 6; i++)
		
  count << arr[i] << " ";
	
  count << end1;

  
	return 0;

  }


  
3. 선택 정렬의 시간 복잡도 분석
 
 선택 정렬의 성능 분석을 위하여 비교횟수와 이동횟수를 따로 구해을 하려고 한다.
 
 - 가정: 비교횟수를 구하기 위하여 두 개의 for로프의 실행횟수를 계산해보자. 외부 루프는 n-1번 반복한다. 내부 루프는 0에서 n-2까지 변하는 i에 대하여 (n-1)i번 반복한다. 키값들의 비교가 내부 루프 안에서 이루어지므로 전체 비교횟수는 다음과 같이 된다.
  
![image](https://user-images.githubusercontent.com/101514626/166666363-82ce90c3-2e2e-44e5-b187-297e0cee2481.png)

  레코드 교환은 외부 루프의 실행횟수만큼 이루어지고, 한번 교환하기 위하여 3번의 이동이 필요하므로 전체 이동횟수는 3(n-1)이 된다.
  
  - 장점: 알고리즘이 매우 간단하다.
  
  - 단점: 선택 정렬의 장점은 자료 이동 횟수가 미리 결정된다는 점이다. 그러나 전체 시간 복잡도가 O(n²)이므로 효율적인 알고리즘은 아니다. 또한 안정성을 만족하지는 않는다. 즉, 값이 같은 레코드가 있는 경우에 상대적인 위치가 변경될 수 있다. 

  
  
  
4. 시간 복잡도(Time Complexity) 및 공간 복잡도(Space Complexity)
  
 알고리즘을 평가할 때는 시간 복작도와 공간 복잡도를 사용합니다.
  
  - 시간 복잡도: 알고리즘의 수행시간을 평가
  - 공간 복잡도: 알고리즘 수행에 필요한 메모리 양을 평가
  
  시간 복잡도와 공간 복잡도는 주로 점근적 표기법 중 빅오 표기법을 이용하여 나타냅니다. (최악의 경우에도 해당 알고리즘이 어떤 성능을 낼지 가늠해볼 수 있기 때문입니다.)
  
  
  
  ▪ 시간 복잡도 (Time Complexity)
 
  수행 시간은 실행환경에 따라 다르게 측정되기 때문에 기본 연산의 실행 횟수로 수행 시간을 평가합니다.
  
  - 기본 연산
  
  i. 데이터 입출력 - copy,move...
  ii. 산술 연산 - add, multiply...
  iii. 제어 연산 - if, while...
  
  시간 복잡도는 3가지 경우로 나타냅니다.
  
 i. 최선의 경우 (Best Case)
  
  - 빅 오메가 사용
  
  - 최선의 시나리오로 최소 이만한 시간이 걸림
  
  ii. 최악의 경우 (Worst Case)
  
  - 빅 오 표기법 사용
  
  - 최악의 시나리오로 아무리 오래 걸려도 이 시간보다 덜 걸림
  
  iii. 평균적인 경우 (Average Case)
  
  - 빅 세타 표기법 사용
  
  - 평균 시간을 나타냄
  
  
 -> 평균적인 경우를 가장 많이 사용할 것 같지만 알고리즘이 복잡해지수록 평균적인 경우는 구하기가 매우 어려워 지기 때문에 최악의 경우로 알고리즘의 성능을 파악합니다.
  
  
  
  ▪ 시간 복잡도 계산
  
  - 시간 복잡도는 일반적으로 빅오 표기법으로 나타냅니다.
  
  - 연산 횟수가 다항식으로 표현될 경우, 최고차항을 제외한 모든 항과 최고차항의 계수를 재외시켜 나타냅니다.
  
  
  Ex) 입력 크기가 n이라고 했을 때 다음과 같이 표기

  - T(n) = n² + 2n + 1 = O(n²) : 최고차항만 나타냄
  
  - T(n) = 2n = O(n) : 최고차항의 계수는 제외함
  
  
  ▪ 시간 복잡도 알고리즘
  
  int func(int n){
  
  int sum = 0; //대입연산 1회
  
  int  = 0; //대입연산 1회
  
  
  for(i=0; i < n; i++){   //반복문 n+1회
                 sum += i;
   }
                 for(i=0;i<n;i++){   //반복문 n+1회
  sum += i;
  }
  return sum;
  }
  
  
  -> 총 연산 횟수는 4n+5이다.
  따라서 이 알고리즘의 시간 복잡도는 T(n) = 4n+5 = O(n)
       
                
  
▪ 시간 복잡도 표기
  
  • O(1) - 상수 시간(Constant time)
  
  입력 크기(n)에 상관없이 일정한 연산을 수행하면 시간복잡도는 O(1)입니다.
  
  void func(int n){
   
    printf("%d\n", n);
  
  }
  
  위 알고리즘은 n에 상관없이 한 번에 연산만 수행하기 대문에 시간 복잡도는 다음과 같습니다.
  
  T(n) = O(1)
  
  
  
  • O(logN) - 로그 시간(Logarithmic time)
  
  입력 크기(N)가 커질 때 연산 횟수가 logN에 비례해서 증가하면 시간 복잡도는 O(logN)입니다.
  
  for(i=1;i<n;i*2){

 ...
               
 }
 
 위 알고리즘은 i값이 반복할 때마다 2배씩 증가합니다. 이것을 k번 반복했을 때 다음과 같습니다.

 2^k = N이 되고 반복문이 종료됩니다.
        
  시간 복잡도 : T(n) = logN
    
  
                    
  • O(n) - 선형 시간 (Linear time)
                    
  입력 크기(n)가 커질 때 연산 횟수가 n에 비례해서 증가하면 시간 복잡도는 O(n)입니다.
  
   - 연산횟수가 선형적으로 증가하는 형태
                    
  for(i=0; i<n; i++){
  
  ...
  
  }
  
  위 알고리즘은 n만큼 반복문을 수행합니다.
  
  n에 값에 비례해서 연산수가 선형적으로 증가하기 때문에 시간 복잡도는 다음과 같습니다.
  
  T(n) = O(n)
  
  
  
 • O(n²) - 2차 시간 (Quadratic time)
  
  입력 크기(n)가 커질 때 연산 횟수가 n²에 비례해서 증가하면 시간 복잡도는 O(n²)입니다.
  
  for(i=0;i<n;i++){
  
                    for(j=o;j<n;j++){
  
  ...
  
  }
  
  위 알고리즘은 for문이 중첩되어 있기 때문에 n²에 비례해서 연산수가 증가합니다.
  
  시간 복잡도 : T(n) = O(n²)
  
  
  
  • O(2^n) - 지수 시간(Exponential time)
  
  입력 크기가 커질 때 연산수가 2^n에 비례해서 증가하면 시간 복잡도는 O(2^n)입니다.
  
  int func(int n){
  
  if(n<=1)  
          
          return n;
          
          return func(n-1)+fun(n-2);
         
          }
  
          
위 알고리즘은 피보나치 수를 구하는 알고리즘입니다.
          
한번 함수를 호출할 때마다 두 번씩 재귀로 함수를 호출하기 때문에 2^n에 비례해서 연산수가 증가합니다.
          
시간 복잡도: T(n) = O(2^n)
          
       
          
![image](https://user-images.githubusercontent.com/101514626/166675763-18db6f7d-cbf6-46d4-85d1-e16097cfae77.png)
          
